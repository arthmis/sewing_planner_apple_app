# API Endpoints and Data Models

## API Endpoints

### Base URL
```
http://localhost:8080
```

### 1. User Signup
**Endpoint**: `POST /signup`

**Request Body**:
```json
{
  "email": "user@example.com",
  "password": "securepassword123"
}
```

**Request Type**: `SignupCredentials`
```rust
#[derive(Deserialize)]
struct SignupCredentials {
    email: String,
    password: String,
}
```

**Response**:
- **Success**: `200 OK` (empty body)
- **Errors**:
  - `400 Bad Request`: Invalid email or invalid password
  - `500 Internal Server Error`: User creation failed or password hash error

**Error Types**:
```rust
pub enum SignupError {
    InvalidEmail,           // Email validation failed
    InvalidPassword,        // Password is empty
    CreateUserFailed,       // Database error
    PasswordHashError,      // Argon2 hashing failed
}
```

**Flow**:
1. Validate email format (RFC compliant)
2. Check password is not empty
3. Hash password with Argon2
4. Insert user into database
5. Return success or specific error

---

### 2. User Login
**Endpoint**: `POST /login`

**Request Body**:
```json
{
  "email": "user@example.com",
  "password": "securepassword123"
}
```

**Request Type**: `UserLogin`
```rust
#[derive(Deserialize)]
struct UserLogin {
    email: Email,
    password: String,
}
```

**Response**:
- **Success**: `200 OK` with session cookie set
- **Errors**:
  - `200 OK`: Invalid credentials (returns OK for security - don't reveal user existence)
  - `500 Internal Server Error`: Session error

**Session**:
- Cookie name: Managed by SessionMiddleware
- TTL: 24 hours (60 * 60 * 24 seconds)
- Secure: Currently `false` (development), should be `true` for production HTTPS
- Stores: `user_id` (i32)

**Error Types**:
```rust
pub enum LoginError {
    InvalidCredentials,     // Wrong email or password
    UserNotFound,          // User doesn't exist (masked as InvalidCredentials)
    SessionError,          // Failed to create session
}
```

**Flow**:
1. Look up user by email
2. Compare password with stored hash (constant-time)
3. Create session with user_id
4. Return success with cookie

---

### 3. WebSocket Connection
**Endpoint**: `GET /ws`

**Protocol**: WebSocket (upgrade from HTTP)

**Authentication**: Currently hardcoded `user_id = 1` (TODO: use session)

**Message Format**: Text (JSON) or Binary

**Message Handling**:
```rust
// Text messages treated as events
AggregatedMessage::Text(text) => {
    let event = events::deserialize_event(text)?;
    events::handle_event(user_id, event, &mut event_database).await?;
}

// Binary messages echoed back
AggregatedMessage::Binary(bin) => {
    ws_session.binary(bin).await?;
}

// Ping messages responded with Pong
AggregatedMessage::Ping(msg) => {
    ws_session.pong(&msg).await?;
}
```

**Connection Limits**:
- Message size: 1 MiB (2^20 bytes) for aggregated/fragmented messages
- Workers: 1 (single-threaded server)

**Flow**:
1. HTTP upgrade to WebSocket
2. Spawn async task to handle messages
3. Deserialize text messages as events
4. Process events through event_database
5. Connection stays open for bidirectional communication

**TODO**: Implement proper session-based authentication for WebSocket connections

---

## Data Models

### User Model (Database)
```rust
#[derive(Queryable, Selectable, Debug)]
#[diesel(table_name = app_db::schema::users)]
pub struct User {
    id: i32,
    email: Email,
    password_hash: String,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}
```

**Database Schema** (PostgreSQL):
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL
);
```

---

### User Input (Insert Model)
```rust
#[derive(Insertable, Debug)]
#[diesel(table_name = app_db::schema::users)]
pub struct UserInput {
    email: Email,
    password_hash: String,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}
```

**Purpose**: Used for inserting new users (no ID, generated by database)

---

### Email Custom Type
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[diesel(sql_type = Text)]
pub struct Email(EmailAddress);
```

**Features**:
- Wraps `email_address::EmailAddress`
- Validates RFC-compliant email format
- Implements Diesel `FromSql` and `ToSql` for database storage
- Serializes/deserializes as string in JSON

**Methods**:
```rust
impl Email {
    pub fn new(email: &str) -> Result<Self, email_address::Error>;
    pub fn as_str(&self) -> &str;
}
```

---

### Project Model (Database)
```rust
// Schema generated by Diesel
diesel::table! {
    projects (id) {
        id -> Int4,
        user_id -> Int4,
        project_id -> Int4,
        title -> Varchar,
        completed -> Bool,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}
```

**Database Schema** (PostgreSQL):
```sql
CREATE TABLE projects (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    project_id INTEGER NOT NULL,
    title VARCHAR(255) NOT NULL,
    completed BOOLEAN NOT NULL,
    created_at TIMESTAMPTZ NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL
);
```

**Relationships**:
- `projects.user_id` â†’ `users.id` (foreign key)

---

## Event System

### Event Processing
Events are processed through the `event_database` module:

```rust
// In events.rs
pub fn deserialize_event(text: ByteString) -> Result<Event, Error>;
pub async fn handle_event(
    user_id: i32,
    event: Event,
    event_database: &mut impl EventDatabase,
) -> Result<(), Error>;
```

**Current Implementation**: Details in `api/src/events.rs`

**Event Database Trait**: Defines operations for event storage and retrieval

---

## Session Management

### Session Store
- **Backend**: SQLite (local file: `sessions.db`)
- **Implementation**: Custom `SqliteSessionStore`
- **Cleanup**: Background task runs every 100 seconds to delete expired sessions

### Session Data
Stored data (minimal for security):
```rust
session.insert("user_id", user.id)?;
```

**Access Session**:
```rust
async fn handler(session: Session) -> Result<HttpResponse, Error> {
    let user_id: Option<i32> = session.get("user_id")?;
    // ...
}
```

### Session Configuration
```rust
SessionMiddleware::builder(session_store, secret_key)
    .cookie_secure(false)  // Set true for HTTPS in production
    .session_lifecycle(
        PersistentSession::default()
            .session_ttl(Duration::new(60 * 60 * 24, 0))  // 24 hours
    )
    .build()
```

---

## Authentication Flow

### Registration Flow
1. Client sends signup request with email and password
2. Server validates email format
3. Server checks password is not empty
4. Server hashes password with Argon2 (with random salt)
5. Server inserts user into PostgreSQL database
6. Server returns success or error

### Login Flow
1. Client sends login request with email and password
2. Server looks up user by email in PostgreSQL
3. Server compares password hash using Argon2 verify (constant-time)
4. If match, server creates session with user_id
5. Server sets session cookie (HttpOnly)
6. Client includes cookie in subsequent requests

### Session Verification
```rust
async fn protected_handler(session: Session) -> Result<HttpResponse, Error> {
    let user_id = session.get::<i32>("user_id")?
        .ok_or(Unauthorized)?;
    
    // User is authenticated, proceed with logic
}
```

---

## CORS Configuration

### Development (Windows)
```rust
let cors = actix_cors::Cors::permissive();
```
- Allows all origins
- Allows all methods
- Allows all headers

### Production (Linux)
```rust
let cors = actix_cors::Cors::default();
```
- More restrictive
- Configure as needed for your frontend domain

---

## Database Connection Configuration

### PostgreSQL (Application Data)
```rust
let database_url = std::env::var("DATABASE_URL")
    .unwrap_or("postgres://postgres:postgres@localhost:7777".to_string());

let config = AsyncDieselConnectionManager::<AsyncPgConnection>::new(database_url);
let pool = Pool::builder(config)
    .max_size(10)
    .build()?;
```

**Pool Settings**:
- Max connections: 10
- Async connections via diesel-async
- Deadpool-based pooling

### SQLite (Sessions)
```rust
let database_url = std::env::var("DATABASE_URL")
    .unwrap_or("./sessions.db".to_string());

let session_conn = SqliteConnection::establish(&database_url)?;
let session_store = SqliteSessionStore::new(session_conn);
```

**Note**: Uses synchronous Diesel for SQLite (simpler for session store)

---

## Response Formats

### Success Response (Empty)
```
HTTP/1.1 200 OK
Content-Length: 0
```

### Success Response (With Cookie)
```
HTTP/1.1 200 OK
Set-Cookie: actix-session=...; HttpOnly; Path=/; Max-Age=86400
Content-Length: 0
```

### Error Response
```
HTTP/1.1 400 Bad Request
Content-Type: text/plain; charset=utf-8

Invalid email
```

**Error Format**: Plain text error message (from error's Display implementation)

---

## Security Considerations

### Password Security
- **Hashing**: Argon2 (memory-hard, resistant to GPU attacks)
- **Salt**: Random salt per password (via `OsRng`)
- **Verification**: Constant-time comparison

### Session Security
- **Storage**: Separate SQLite database
- **Cookie**: HttpOnly (not accessible via JavaScript)
- **TTL**: 24 hours (automatic expiration)
- **Cleanup**: Expired sessions deleted every 100 seconds

### Input Validation
- Email: RFC-compliant validation via `email_address` crate
- Password: Non-empty check (minimum requirement)
- TODO: Consider password strength requirements

### SQL Injection Prevention
- All queries use Diesel query builder (parameterized)
- No raw SQL with user input

---

## API Client Examples

### Signup Example (curl)
```bash
curl -X POST http://localhost:8080/signup \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"SecurePass123"}'
```

### Login Example (curl)
```bash
curl -X POST http://localhost:8080/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"SecurePass123"}' \
  -c cookies.txt  # Save cookies to file
```

### WebSocket Example (JavaScript)
```javascript
const ws = new WebSocket('ws://localhost:8080/ws');

ws.onopen = () => {
    console.log('Connected');
    // Send event
    ws.send(JSON.stringify({ type: 'create_project', data: {...} }));
};

ws.onmessage = (event) => {
    console.log('Received:', event.data);
};
```

### Authenticated Request (curl)
```bash
curl -X GET http://localhost:8080/protected \
  -b cookies.txt  # Load cookies from file
```